\documentclass[main.tex]{subfiles}

\section{The Test Problem and DOPRI54}

In this first section we are going to implement a set of numerical methods for solving ordinary differential equations. Since the algorithms are only approximations to the real solution, we shall also test their accuracy and discuss their performance by comparing the results obtained when solving the two following initial value problems:

EQUATIONS


\subsection{Explicit and Implicit Euler's method and Trapezoidal method}

As a first approach, we are going to implement the Explicit Euler's method. The algorithm makes use of finite difference methods to replace the derivatives in the differential equation. The independent variable is discretized and the solution is computed based on cosequtive approximations to the real function values.

TALK ABOUT STEP LENGTH

EQUATION FORWARD EULER

Instead of using the previous iterate one could also look at future values to approximate a solution. This method is called backward or implicit Euler:

EQUATION BACKWARD EULER

However, for some problems the solution of the previous equation may require the use of numerical solvers, and thus the algorithm becomes computationally more demanding than the explicit Euler's method. We shall see in the next section the advantange of using this method.

Besides, the trapezodial method can be seen as a combination of both methods:

DESCRIBE TRAPEZOIDAL

Figure \ref{fig:solEulerTrap} shows the solution of the two initial value problems given by explicit, implicit Euler and trapezoidal, along with the true solution. 

\subsection{Global and local errors}

It is easy to see in figure \ref{fig:solEulerTrap}, especially in the graph on the right, that, since we base the solution at one point on previous approximations, the further the points are from the initial value the more inaccurate they become and the greater the distance to the true solution is. This distance is called global error, whilst the error made in every iteration is known as local error. As we will discuss later the latter is commonly used to classify different methods depending in their accuracy.

One could then derive the analytical expression of the solution for both problems and compute te local and global errors.

ANALYTICAL SOLUTION TO THE PROBLEMS.

GLOBAL.

Figure \ref{fig:global1} represents the global error at time $t = 10$ made by the three implemented solvers for different step sizes. As expected, the size the global error decreases when increasing the number of points used in the approximation. Besides, figure \ref{fig:global2} shows the global error from $t = 0$ to $t = 10$.

On the other hand the local error at time $t = t_0 + h$, can be computed as:

EQUATION

Figure \ref{fig:local1} shows the local error at the first iteration. Again we see how the error decreases with the step size. Moreover, as the plots use logarithmic scale and the curves are approximately straight lines, we can conclude that there is an exponential dependence between local error and step size or in big O notation: $O(h^{p+1})$. The constant p is used to characterize different methods, thus we say that a method is order 2 when the local error is proportional to$h^{3}$. The dashed lines in figure \ref{fig:local1} can be used to determined the order of the three solvers. That is, order 1 for Explicit and Implicit Euler and order 2 for the Trapezoidal method.

\subsection{Error estimation}

Considering that the algorithms are used to solve differential equations that are hard to derive analyticaly, calculate the exact error is not always possible.

An easy way to estimate the local error is called step doubling. The solution is computed for ...
(performance). It turns out that estimate is proportional to the exact error and we can then 

More sophisticated algorithms use embbeded methods of lower order to estimate the error. This secondary method will be closely related to the main algorithm so that they can share computations and thus be very efficient.

The local error estimates are plotted along with the true errors in figure \ref{fig:errEst} for different step sizes. Even though, they do not match the exact values for some of the methods, the estimates lie always above the true errors which means that they can be used as an upper bound. Besides, as we know that the estimates are proportional to the exact local errors their slope can be used to verify the order of accuracy.
