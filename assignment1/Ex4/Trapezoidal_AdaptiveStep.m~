function [T,Y] = Trapezoidal_AdaptiveStep(funJac,tspan,n,y0,varargin)

% Controller parameters
epstol = 0.8;
facmin = 0.1;
facmax = 5.0;

% Set tolerance and max number of iterations for the solver
tol = 1.0e-8;
maxit = 100;

% Compute initial step size
h0 = (tspan(2)-tspan(1))/n;
hn = h0;

% Trapezoidal method
Y(:,1) = y0;
T(1) = tspan(1);

while T(end) < tspan(2)
    
    % Size of last step
    if T(end)+hn > tspan(2)
        hn = tspan(2) - T(end);
    end
    
    f = feval(funJac,T(end),Y(:,end),varargin{:});
    
    h = h0;
    AcceptStep = false;
    while ~ AcceptStep
        h = hn;
        
        % Step size h
        
        % Compute explicit Euler and use it as initial value
        yinit = Y(:,end) + h*f;

        % Solve implicit equation
        Y(:,end+1) = NewtonsTrapezoidal(funJac, ...
                     T(end),Y(:,end),h,yinit,tol,maxit,varargin{:});
        
        % Step size h/2
        
        hm = 0.5*h;
        Tm = T(end) + hm;
        
        % Compute first half step
        yinit = Y(:,end) + hm*f;
        Ym = NewtonsTrapezoidal(funJac,...
             T(end),Y(:,end),h,yinit,tol,maxit,varargin{:});
        
        % Compute second half step
        fm = feval(funJac,Tm,Ym,varargin{:});
        yinit = Ym + hm*fm;
        Yhat = NewtonsTrapezoidal(funJac,...
               T(end),Y(:,end),h,yinit,tol,maxit,varargin{:});
        
        % Error estimation
        e = Y1 - Yhat;
        r = max(abs(e)./mac(abstol,abs(Yhat).*reltol));
        
        % C
    end
T(end+1) = T(end)+h;    
end

Y = Y';
end